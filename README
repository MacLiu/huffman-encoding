# Data compression via Huffman Encoding - Rohan Varma

# Running the code

To run the code, Python3 is required. I used Python 3.5 for my development of this project. I tried to limit the external dependencies in this project, but you will also need pickle and heapq to run the code.

Run encoding algorithm: `python3 huffman.py encode FILENAME`
Run decoding algorithm: `python3 huffman.py decode FILENAME`
The encoded file written to is "compressed.txt"
After decoding, the file that is written to is "decoded.txt".
A general pattern may be as follows:
`python3 huffman.py encode data.txt`
`python3 huffman.py decode compressed.txt`
`diff data.txt decoded.txt` -> expect no diff.

Run tests: `python3 huffman.py test`

If you input a wrong command line arg, a usage string is printed out. 
# Use of Huffman Algorithm
I chose to use Huffman encoding to solve this compression problem. Huffman encoding works especially well for larger files with a lot of (not necessarily continuous) repitition. Huffman encoding also has the nice property that frequently occuring letters can be represented more compactly than letters that do not occur very often.

I considered another algorithm, run-length encoding, but the drawbacks of that algorithm, such as the fact that it does not work well at all when there are not significant chunks of repetition, is what led me to use Huffman. While RLE may have been useful on the given dataset, I do not believe that it would generalize well to other files. 

# Implementation

To implement huffman encoding, I first built a frequency dictionary that mapped each unique character to how many times it occured in the text. Next, I constructed the huffman tree through the use of a priority queue. After that, I ran DFS on the tree to populate the leaf nodes with their encodings. Finally, I wrote out the encoding after converting it to hex. 
To implement decoding, I simply read off the encoded text and dictionary I used to map binary keys to actual characters. I then iterated through the binary string, looking for keys. The property of Huffman encodings - that no binary encoding can ever be a prefix for another binary encoding proved very useful.

# Future Work

For future work, I would spend some more time improving my conversion of the integer string to a hex string. For now, I used a small workaround that appends a zero when the data is incorrect. 
I would also like to examine whether the tree can be built in a more efficient manner, and if less intermediate space is needed in the encode() algorithm. 

